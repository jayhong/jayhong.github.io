<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jayhong博客</title>
    <link>https://jayhong.github.io/</link>
    <description>Recent content on jayhong博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 04 Mar 2019 21:38:52 +0800</lastBuildDate>
    
        <atom:link href="https://jayhong.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关于</title>
      <link>https://jayhong.github.io/about/</link>
      <pubDate>Mon, 04 Mar 2019 21:38:52 +0800</pubDate>
      
      <guid>https://jayhong.github.io/about/</guid>
      
        <description>&lt;ul&gt;
&lt;li&gt;Golang 程序员，喜欢技术，热爱钻研。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>golang reflect 剖析</title>
      <link>https://jayhong.github.io/post/20190313-golang-reflect-%E5%89%96%E6%9E%90/</link>
      <pubDate>Wed, 13 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jayhong.github.io/post/20190313-golang-reflect-%E5%89%96%E6%9E%90/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;http://legendtkl.com/2017/07/01/golang-interface-implement/&#34;&gt;http://legendtkl.com/2017/07/01/golang-interface-implement/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://legendtkl.com/2017/06/12/understanding-golang-interface/&#34;&gt;http://legendtkl.com/2017/06/12/understanding-golang-interface/&lt;/a&gt;
&lt;a href=&#34;http://wudaijun.com/2018/01/go-interface-implement/&#34;&gt;http://wudaijun.com/2018/01/go-interface-implement/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>golang interface 剖析</title>
      <link>https://jayhong.github.io/post/20190311-golang-interface-%E5%89%96%E6%9E%90/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jayhong.github.io/post/20190311-golang-interface-%E5%89%96%E6%9E%90/</guid>
      
        <description>

&lt;h3 id=&#34;interface-是什么&#34;&gt;interface 是什么？&lt;/h3&gt;

&lt;p&gt;interface 是一种具有一组方法的类型，这些方法定义了 interface 的行为。&lt;/p&gt;

&lt;p&gt;go 允许不带任何方法的 interface ，这种类型的 interface 叫 empty interface。&lt;/p&gt;

&lt;p&gt;如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface，
所以所有类型都实现了 empty interface，因为任何一种类型至少实现了 0 个方法。go 没有显式的关键字用来实现 interface，只需要实现 interface 包含的方法即可。&lt;/p&gt;

&lt;p&gt;在 Gopher China 2017 的会上又有一个关于 interface 的 topic: (understanding golang interface(Gopher China))[&lt;a href=&#34;https://www.youtube.com/watch?v=F4wUrj6pmSI&amp;amp;t=2319s&#34;&gt;https://www.youtube.com/watch?v=F4wUrj6pmSI&amp;amp;t=2319s&lt;/a&gt;] — youtube，
作者是 Francesc。&lt;/p&gt;

&lt;h3 id=&#34;为什么需要interface&#34;&gt;为什么需要interface ?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1、泛型编程
泛型编程是指实现一个方法可以用于多种不同的数据类型。
在golang中是没有泛型编程的。golang中的泛型编程可以通过interface{} 进行实现.
golang标准库中的sort&lt;code&gt;src/sort/sort.go&lt;/code&gt; 就实现了类似于泛型编程的东西。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;package sort

// A type, typically a collection, that satisfies sort.Interface can be
// sorted by the routines in this package.  The methods require that the
// elements of the collection be enumerated by an integer index.
type Interface interface {
    // Len is the number of elements in the collection.
    Len() int
    // Less reports whether the element with
    // index i should sort before the element with index j.
    Less(i, j int) bool
    // Swap swaps the elements with indexes i and j.
    Swap(i, j int)
}

...

// Sort sorts data.
// It makes one call to data.Len to determine n, and O(n*log(n)) calls to
// data.Less and data.Swap. The sort is not guaranteed to be stable.
func Sort(data Interface) {
    // Switch to heapsort if depth of 2*ceil(lg(n+1)) is reached.
    n := data.Len()
    maxDepth := 0
    for i := n; i &amp;gt; 0; i &amp;gt;&amp;gt;= 1 {
        maxDepth++
    }
    maxDepth *= 2
    quickSort(data, 0, n, maxDepth)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任意的数据类型只要实现了sort的三个方法就可以调用sort方法进行排序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2、隐藏实现
比如我设计一个函数给你返回一个 interface，那么你只能通过 interface 里面的方法来做一些操作，
但是内部的具体实现是完全不知道的。Francesc 举了个 context 的例子。 context 最先由 google 提供，
现在已经纳入了标准库，而且在原有 context 的基础上增加了：cancelCtx，timerCtx，valueCtx。
语言的表达有时候略显苍白无力，看一下 context 包的代码吧。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &amp;amp;c)
    return &amp;amp;c, func() { c.cancel(true, Canceled) }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表面上 WithCancel 函数返回的还是一个 Context interface，但是这个 interface 的具体实现是 cancelCtx struct。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// newCancelCtx returns an initialized cancelCtx.
func newCancelCtx(parent Context) cancelCtx {
    return cancelCtx{
        Context: parent,
        done:    make(chan struct{}),
    }
}

// A cancelCtx can be canceled. When canceled, it also cancels any children
// that implement canceler.
type cancelCtx struct {
    Context     //注意一下这个地方

    done chan struct{} // closed by the first cancel call.
    mu       sync.Mutex
    children map[canceler]struct{} // set to nil by the first cancel call
    err      error                 // set to non-nil by the first cancel call
}

func (c *cancelCtx) Done() &amp;lt;-chan struct{} {
    return c.done
}

func (c *cancelCtx) Err() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.err
}

func (c *cancelCtx) String() string {
    return fmt.Sprintf(&amp;quot;%v.WithCancel&amp;quot;, c.Context)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;尽管内部实现上下面三个函数返回的具体 struct （都实现了 Context interface）不同，但是对于使用者来说是完全无感知的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func WithCancel(parent Context) (ctx Context, cancel CancelFunc)    //返回 cancelCtx
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) //返回 timerCtx
func WithValue(parent Context, key, val interface{}) Context    //返回 valueCtx
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3、providing interception points
这个的意思估计就是提供埋点
```
type header struct {
rt  http.RoundTripper
v   map[string]string
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;func (h header) RoundTrip(r *http.Request) *http.Response {
    for k, v := range h.v {
        r.Header.Set(k,v)
    }
    return h.rt.RoundTrip&amp;reg;
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;目前opentracing 官方提供的库就用到了这个。在http的接口加多了一个中间件
https://github.com/opentracing-contrib/go-stdlib/blob/master/nethttp/server.go#L111


### interface 源码剖析
interface 在golang中是由两个结构体实现的，一个是eface 一个是iface
#### eface
eface在`runtime/runtime2.go` 中定义

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// src/runtime/runtime2.go
// 空接口
type eface struct {
    _type *_type
    data  unsafe.Pointer
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
空接口(eface)有两个域，所指向对象的类型信息(_type)和数据指针(data)。先看看_type字段：

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/ 所有类型信息结构体的公共部分
// src/rumtime/runtime2.go
type _type struct {
    size       uintptr         // 类型的大小
    ptrdata    uintptr      // size of memory prefix holding all pointers
    hash       uint32          // 类型的Hash值
    tflag      tflag              // 类型的Tags
    align      uint8       // 结构体内对齐
    fieldalign uint8       // 结构体作为field时的对齐
    kind       uint8       // 类型编号 定义于runtime/typekind.go
    alg        *typeAlg    // 类型元方法 存储hash和equal两个操作。map key便使用key的_type.alg.hash(k)获取hash值
    gcdata    *byte            // GC相关信息
    str       nameOff   // 类型名字的偏移&lt;br /&gt;
    ptrToThis typeOff&lt;br /&gt;
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
_type是go所有类型的公共描述，里面包含GC，反射等需要的细节，它决定data应该如何解释和操作，这也是它和C void*不同之处。
各个类型所需要的类型描述是不一样的，比如chan，除了chan本身外，还需要描述其元素类型，而map则需要key类型信息和value类型信息等:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;/ src/runtime/type.go
// ptrType represents a pointer type.
type ptrType struct {
   typ     _type   // 指针类型
   elem  *_type // 指针所指向的元素类型
}
type chantype struct {
    typ  _type        // channel类型
    elem *_type     // channel元素类型
    dir  uintptr
}
type maptype struct {
    typ           _type
    key           *_type
    elem          *_type
    bucket        *_type // internal type representing a hash bucket
    hmap          *_type // internal type representing a hmap
    keysize       uint8  // size of key slot
    indirectkey   bool   // store ptr to key instead of key itself
    valuesize     uint8  // size of value slot
    indirectvalue bool   // store ptr to value instead of value itself
    bucketsize    uint16 // size of bucket
    reflexivekey  bool   // true if k==k for all keys
    needkeyupdate bool   // true if we need to update key on an overwrite
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
这些类型信息的第一个字段都是_type(类型本身的信息)，接下来是一堆类型需要的其它详细信息(如子类型信息)，这样在进行类型相关操作时，
可通过一个字(typ *_type)即可表述所有类型，然后再通过_type.kind可解析出其具体类型，最后通过地址转换即可得到类型完整的”_type树”，参考reflect.Type.Elem()函数:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// reflect/type.go
// reflect.rtype结构体定义和runtime._type一致  type.kind定义也一致(为了分包而重复定义)
// Elem()获取rtype中的元素类型，只针对复合类型(Array, Chan, Map, Ptr, Slice)有效
func (t *rtype) Elem() Type {
   switch t.Kind() {
   case Array:
      tt := (*arrayType)(unsafe.Pointer(t))
      return toType(tt.elem)
   case Chan:
      tt := (*chanType)(unsafe.Pointer(t))
      return toType(tt.elem)
   case Map:
      // 对Map来讲，Elem()得到的是其Value类型
      // 可通过rtype.Key()得到Key类型
      tt := (*mapType)(unsafe.Pointer(t))
      return toType(tt.elem)
   case Ptr:
      tt := (*ptrType)(unsafe.Pointer(t))
      return toType(tt.elem)
   case Slice:
      tt := (*sliceType)(unsafe.Pointer(t))
      return toType(tt.elem)
   }
   panic(&amp;ldquo;reflect: Elem of invalid type&amp;rdquo;)
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#### iface

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// runtime/runtime2.go
// 非空接口
type iface struct {
    tab  *itab
    data unsafe.Pointer
}&lt;/p&gt;

&lt;p&gt;// 非空接口的类型信息
type itab struct {
    inter  *interfacetype    // 接口定义的类型信息
    _type  *_type                // 接口实际指向值的类型信息
    link   *itab&lt;br /&gt;
    bad    int32
    inhash int32
    fun    [1]uintptr             // 接口方法实现列表，即函数地址列表，按字典序排序
}&lt;/p&gt;

&lt;p&gt;// runtime/type.go
// 非空接口类型，接口定义，包路径等。
type interfacetype struct {
   typ     _type
   pkgpath name
   mhdr    []imethod      // 接口方法声明列表，按字典序排序
}&lt;/p&gt;

&lt;p&gt;// 接口的方法声明
type imethod struct {
   name nameOff          // 方法名
   ityp typeOff                // 描述方法参数返回值等细节
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
非空接口(iface)本身除了可以容纳满足其接口的对象之外，还需要保存其接口的方法，因此除了data字段，iface通过tab字段描述非空接口的细节
，包括接口方法定义，接口方法实现地址，接口所指类型等。iface是非空接口的实现，而不是类型定义，iface的真正类型为interfacetype，其第一个字段仍然为描述其自身类型的_type字段。

为了提高查找效率，runtime中实现(interface_type, concrete_type) -&amp;gt; itab(包含具体方法实现地址等信息)的hash表:

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// runtime/iface.go
const (
   hashSize = 1009
)&lt;/p&gt;

&lt;p&gt;var (
   ifaceLock mutex // lock for accessing hash
   hash      [hashSize]*itab
)
// 简单的Hash算法
func itabhash(inter *interfacetype, typ *_type) uint32 {
   h := inter.typ.hash
   h += 17 * typ.hash
   return h % hashSize
}&lt;/p&gt;

&lt;p&gt;// 根据interface_type和concrete_type获取或生成itab信息
func getitab(inter *interfacetype, typ *_type, canfail bool) *itab {
   &amp;hellip;
    // 算出hash key
   h := itabhash(inter, typ)&lt;/p&gt;

&lt;p&gt;var m *itab
   &amp;hellip;
           // 遍历hash slot链表
      for m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;amp;hash[h]))); m != nil; m = m.link {
         // 如果在hash表中找到则返回
         if m.inter == inter &amp;amp;&amp;amp; m._type == typ {
            if m.bad {
               if !canfail {
                  additab(m, locked != 0, false)
               }
               m = nil
            }
            &amp;hellip;
            return m
         }
      }
   }
    // 如果没有找到，则尝试生成itab(会检查是否满足接口)
   m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;amp;memstats.other_sys))
   m.inter = inter
   m._type = typ
   additab(m, true, canfail)
   if m.bad {
      return nil
   }
   return m
}&lt;/p&gt;

&lt;p&gt;// 检查concrete_type是否符合interface_type 并且创建对应的itab结构体 将其放到hash表中
func additab(m *itab, locked, canfail bool) {
   inter := m.inter
   typ := m._type
   x := typ.uncommon()&lt;/p&gt;

&lt;p&gt;ni := len(inter.mhdr)
   nt := int(x.mcount)
   xmhdr := (*[1 &amp;lt;&amp;lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]
   j := 0
   for k := 0; k &amp;lt; ni; k++ {
      i := &amp;amp;inter.mhdr[k]
      itype := inter.typ.typeOff(i.ityp)
      name := inter.typ.nameOff(i.name)
      iname := name.name()
      ipkg := name.pkgPath()
      if ipkg == &amp;ldquo;&amp;rdquo; {
         ipkg = inter.pkgpath.name()
      }
      for ; j &amp;lt; nt; j++ {
         t := &amp;amp;xmhdr[j]
         tname := typ.nameOff(t.name)
         // 检查方法名字是否一致
         if typ.typeOff(t.mtyp) == itype &amp;amp;&amp;amp; tname.name() == iname {
            pkgPath := tname.pkgPath()
            if pkgPath == &amp;ldquo;&amp;rdquo; {
               pkgPath = typ.nameOff(x.pkgpath).name()
            }
            // 是否导出或在同一个包
            if tname.isExported() || pkgPath == ipkg {
               if m != nil {
                    // 获取函数地址，并加入到itab.fun数组中
                  ifn := typ.textOff(t.ifn)
                  *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn
               }
               goto nextimethod
            }
         }
      }
      // didn&amp;rsquo;t find method
      if !canfail {
         if locked {
            unlock(&amp;amp;ifaceLock)
         }
         panic(&amp;amp;TypeAssertionError{&amp;ldquo;&amp;rdquo;, typ.string(), inter.typ.string(), iname})
      }
      m.bad = true
      break
   nextimethod:
   }
   if !locked {
      throw(&amp;ldquo;invalid itab locking&amp;rdquo;)
   }
   // 加到Hash Slot链表中
   h := itabhash(inter, typ)
   m.link = hash[h]
   m.inhash = true
   atomicstorep(unsafe.Pointer(&amp;amp;hash[h]), unsafe.Pointer(m))
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
### 接口赋值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;fmt&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;type MyInterface interface {
    Print()
}&lt;/p&gt;

&lt;p&gt;type MyStruct struct{}
func (ms MyStruct) Print() {}&lt;/p&gt;

&lt;p&gt;func main() {
    x := 1
    var y interface{} = x
    var s MyStruct
    var t MyInterface = s
    fmt.Println(y, z)
}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
代码 17 行 var y interface{} = x 调用了函数 runtime.convT2E ，将 int 类型的 x 转换成 empty interface。
代码 19 行 var t MyInterface = s 将 MyStruct 类型转换成 non-empty interface: MyInterface

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;func convT2E(t *_type, elem unsafe.Pointer) (e eface) {
    &amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x := newobject(t)
typedmemmove(t, x, elem)
e._type = t
e.data = x
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func convT2I(tab *itab, elem unsafe.Pointer) (i iface) {
    t := tab._type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...

x := newobject(t)
typedmemmove(t, x, elem)
i.tab = tab
i.data = x
return
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
看上面的函数原型，可以看出中间过程编译器将根据我们的转换目标类型的 empty interface 还是 non-empty interface，
来对原数据类型进行转换（转换成 &amp;lt;*_type, unsafe.Pointer&amp;gt; 或者 &amp;lt;*itab, unsafe.Pointer&amp;gt;）。这里对于 struct 满不
满足 interface 的类型要求（也就是 struct 是否实现了 interface 的所有 method），是由编译器来检测的。

### Type Assertion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;// The assertXXX functions may fail (either panicking or returning false,
// depending on whether they are 1-result or 2-result).
func assertI2I(inter *interfacetype, i iface) (r iface) {
    tab := i.tab
    if tab == nil {
        // explicit conversions require non-nil interface value.
        panic(&amp;amp;TypeAssertionError{&amp;ldquo;&amp;rdquo;, &amp;ldquo;&amp;rdquo;, inter.typ.string(), &amp;ldquo;&amp;rdquo;})
    }
    if tab.inter == inter {
        r.tab = tab
        r.data = i.data
        return
    }
    r.tab = getitab(inter, tab._type, false)
    r.data = i.data
    return
}
func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) {
    tab := i.tab
    if tab == nil {
        return
    }
    if tab.inter != inter {
        tab = getitab(inter, tab._type, true)
        if tab == nil {
            return
        }
    }
    r.tab = tab
    r.data = i.data
    b = true
    return
}&lt;/p&gt;

&lt;p&gt;// 类似
func assertE2I(inter *interfacetype, e eface) (r iface)
func assertE2I2(inter *interfacetype, e eface) (r iface, b bool)
```&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;interface 是有两个结构体组成的iface 和eface，eface是有一个_type和指针构成，iface是有itab 和指针构成
iface里面有_type 和 方法列表哈希值
接口的赋值是通过convT2I convT2E assertE2I 来实现的&lt;/p&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/InterfaceSlice&#34;&gt;https://github.com/golang/go/wiki/InterfaceSlice&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/&#34;&gt;https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://legendtkl.com/2017/07/01/golang-interface-implement/&#34;&gt;http://legendtkl.com/2017/07/01/golang-interface-implement/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://legendtkl.com/2017/06/12/understanding-golang-interface/&#34;&gt;http://legendtkl.com/2017/06/12/understanding-golang-interface/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://i6448038.github.io/2018/10/01/Golang-interface/&#34;&gt;https://i6448038.github.io/2018/10/01/Golang-interface/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://wudaijun.com/2018/01/go-interface-implement/&#34;&gt;http://wudaijun.com/2018/01/go-interface-implement/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>golang channel实现原理</title>
      <link>https://jayhong.github.io/post/20190307-golang-channel-%E5%89%96%E6%9E%90/</link>
      <pubDate>Thu, 07 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jayhong.github.io/post/20190307-golang-channel-%E5%89%96%E6%9E%90/</guid>
      
        <description>

&lt;h3 id=&#34;channel&#34;&gt;channel&lt;/h3&gt;

&lt;p&gt;要想理解 channel 要先知道 CSP 模型。CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，由 Tony Hoare 于 1977 年提出。简单来说，CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。，golang 使用了channel实现了CSP并发编程模型，
下面将从源码的角度来分析channel，首先会先看下channel支持的操作，然后再分析这些操作对应的源代码。&lt;/p&gt;

&lt;h3 id=&#34;channel相关操作&#34;&gt;channel相关操作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;chan分为阻塞式的和非阻塞类的chan&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//创建一个阻塞类chan
ch := make(chan int)
//创建一个非阻塞类chan
ch := make(chan int， 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;往chan写数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ch &amp;lt;- 1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从chan中读数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a := &amp;lt;- ch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关闭 channel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;close(ch)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看chan的cap 和len&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
ch := make(chan int, 100)
ch &amp;lt;- 1
fmt.Println(len(ch)) // 1
fmt.Println(cap(ch)) // 100
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;goroutine 通信&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;select&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;range channel&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;超时控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生产者-消费者模型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单向 channel&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;chan使用需要注意的问题&#34;&gt;chan使用需要注意的问题&lt;/h3&gt;

&lt;h4 id=&#34;close-chan&#34;&gt;close chan&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;关闭一个已经关闭的chan会导致panic&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关闭chan会退出循环&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; func main() {
    ch := make(chan int, 100)
    for elem := range ch { // 主要就是这里的 for range...
        fmt.Println(i)
    }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;往关闭的chan发送数据会导致panic&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 close channel 时，有 sender goroutine 挂在 channel 的阻塞发送队列中，
会导致 panic：close 一个 channel 会唤醒所有等待在该 channel 上的 g，并使其进入 Grunnable 状态，
这时这些 writer goroutine 会发现该 channel 已经是 closed 状态，就 panic了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; func main() {
    ch := make(chan int)
    go func() { ch &amp;lt;- 1 }() // panic: send on closed channel
    time.Sleep(time.Second)
    go func() { close(ch) }()
    time.Sleep(time.Second)
    x, ok := &amp;lt;-ch
    fmt.Println(x, ok)
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以从已经 closed 的 channel 中接收值，如果 channel 中有值，这里特指带 buffer 的 channel，那么就从 channel 中取，如果没有值，那么会返回 channel 元素的 0 值。
区分是返回的零值还是 buffer 中的值可使用 comma, ok 语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//若 ok 为 false，表明 channel 已被关闭，所得的是无效的值
x, ok := &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;nil-chan&#34;&gt;nil chan&lt;/h4&gt;

&lt;p&gt;不进行初始化，即不调用 make 来赋值的 channel 称为 nil channel&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; var a chan int
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭一个nil的chan会导致panic&lt;/p&gt;

&lt;h4 id=&#34;close-principle&#34;&gt;close principle&lt;/h4&gt;

&lt;h3 id=&#34;channel源码&#34;&gt;channel源码&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;src/runtime/chan.go:hchan&lt;/code&gt;定义了channel的数据结构：&lt;/p&gt;

&lt;h4 id=&#34;hchan-struct&#34;&gt;hchan struct&lt;/h4&gt;

&lt;p&gt;chan的底层就是hchan&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type hchan struct {
    qcount   uint           // 队列中数据个数
    dataqsiz uint           // channel 大小
    buf      unsafe.Pointer // 存放数据的环形数组
    elemsize uint16         // channel 中数据类型的大小
    closed   uint32         // 表示 channel 是否关闭
    elemtype *_type // 元素数据类型
    sendx    uint   // send 的数组索引
    recvx    uint   // recv 的数组索引
    recvq    waitq  // 由 recv 行为（也就是 &amp;lt;-ch）阻塞在 channel 上的 goroutine 队列
    sendq    waitq  // 由 send 行为 (也就是 ch&amp;lt;-) 阻塞在 channel 上的 goroutine 队列

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}
type waitq struct {
    first *sudog
    last  *sudog
}
type sudog struct {
    // The following fields are protected by the hchan.lock of the
    // channel this sudog is blocking on. shrinkstack depends on
    // this for sudogs involved in channel ops.

    g          *g
    selectdone *uint32 // CAS to 1 to win select race (may point to stack)
    next       *sudog
    prev       *sudog
    elem       unsafe.Pointer // data element (may point to stack)

    // The following fields are never accessed concurrently.
    // For channels, waitlink is only accessed by g.
    // For semaphores, all fields (including the ones above)
    // are only accessed when holding a semaRoot lock.

    acquiretime int64
    releasetime int64
    ticket      uint32
    parent      *sudog // semaRoot binary tree
    waitlink    *sudog // g.waiting list or semaRoot
    waittail    *sudog // semaRoot
    c           *hchan // channel
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;channel 其实就是一个队列加一个锁，只不过这个锁是一个轻量级锁。其中 recvq 是读操作阻塞在 channel 的 goroutine 列表，
 sendq 是写操作阻塞在 channel 的 goroutine 列表。列表的实现是 sudog，其实就是一个对 g 的结构的封装&lt;/p&gt;

&lt;h4 id=&#34;make-channel&#34;&gt;make channel&lt;/h4&gt;

&lt;p&gt;通过 make 创建 channel 对应的代码如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func makechan(t *chantype, size int64) *hchan {
    elem := t.elem

    // compiler checks this but be safe.
    if elem.size &amp;gt;= 1&amp;lt;&amp;lt;16 {
        throw(&amp;quot;makechan: invalid channel element type&amp;quot;)
    }
    if hchanSize%maxAlign != 0 || elem.align &amp;gt; maxAlign {
        throw(&amp;quot;makechan: bad alignment&amp;quot;)
    }
    if size &amp;lt; 0 || int64(uintptr(size)) != size || (elem.size &amp;gt; 0 &amp;amp;&amp;amp; uintptr(size) &amp;gt; (_MaxMem-hchanSize)/elem.size) {
        panic(plainError(&amp;quot;makechan: size out of range&amp;quot;))
    }

    var c *hchan
    if elem.kind&amp;amp;kindNoPointers != 0 || size == 0 {
        // Allocate memory in one call.
        // Hchan does not contain pointers interesting for GC in this case:
        // buf points into the same allocation, elemtype is persistent.
        // SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
        // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
        c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
        if size &amp;gt; 0 &amp;amp;&amp;amp; elem.size != 0 {
            c.buf = add(unsafe.Pointer(c), hchanSize)
        } else {
            // race detector uses this location for synchronization
            // Also prevents us from pointing beyond the allocation (see issue 9401).
            c.buf = unsafe.Pointer(c)
        }
    } else {
        c = new(hchan)
        c.buf = newarray(elem, int(size))
    }
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)

    if debugChan {
        print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; elemalg=&amp;quot;, elem.alg, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
    }
    return c
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最前面的两个 if 是一些异常判断：元素类型大小限制和对齐限制。第三个 if 也很明显，判断 size 大小是否小于 0 或者过大。
&lt;code&gt;int64(uintptr(size)) != size&lt;/code&gt;这句也是判断 size 是否为负。值得一说的是最后面的判断条件&lt;/p&gt;

&lt;p&gt;_MaxMem 是 Arena 区域的最大值，用来分配给堆的。也就是说 channel 是在堆上分配的。&lt;/p&gt;

&lt;p&gt;再往下就可以看到分配的代码了。如果 channel 内数据类型不含有指针且 size &amp;gt; 0，则将其分配在连续的内存区域。如果 size = 0，实际上 buf 是不分配空间的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if elem.kind&amp;amp;kindNoPointers != 0 || size == 0 {
    // Allocate memory in one call.
    // Hchan does not contain pointers interesting for GC in this case:
    // buf points into the same allocation, elemtype is persistent.
    // SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
    // TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
    c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
    if size &amp;gt; 0 &amp;amp;&amp;amp; elem.size != 0 {
        c.buf = add(unsafe.Pointer(c), hchanSize)
    } else {
        // race detector uses this location for synchronization
        // Also prevents us from pointing beyond the allocation (see issue 9401).
        c.buf = unsafe.Pointer(c)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;除了上面的情况，剩下的，也就是 size &amp;gt; 0，channel 和 channel.buf 是分别进行分配的。剩下的代码是剩下字段的处理。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;else {
        c = new(hchan)
        c.buf = newarray(elem, int(size))   // newarray 也是调用 mallocgc 进行内存分配
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;go 1.10的代码，if else 使用switch 重写了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;send&#34;&gt;send&lt;/h4&gt;

&lt;p&gt;send 也就是 ch &amp;lt;- x，对应的函数如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// entry point for c &amp;lt;- x from compiled code
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
    chansend(c, elem, true, getcallerpc(unsafe.Pointer(&amp;amp;c)))
}

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    if c == nil {
        if !block {
            return false
        }
        gopark(nil, nil, &amp;quot;chan send (nil chan)&amp;quot;, traceEvGoStop, 2)
        throw(&amp;quot;unreachable&amp;quot;)
    }
    ...
    
    if !block &amp;amp;&amp;amp; c.closed == 0 &amp;amp;&amp;amp; ((c.dataqsiz == 0 &amp;amp;&amp;amp; c.recvq.first == nil) ||
        (c.dataqsiz &amp;gt; 0 &amp;amp;&amp;amp; c.qcount == c.dataqsiz)) {
        return false
    }

    var t0 int64
    if blockprofilerate &amp;gt; 0 {
        t0 = cputicks()
    }

    lock(&amp;amp;c.lock)

    if c.closed != 0 {
        unlock(&amp;amp;c.lock)
        panic(plainError(&amp;quot;send on closed channel&amp;quot;))
    }

    if sg := c.recvq.dequeue(); sg != nil {
        // Found a waiting receiver. We pass the value we want to send
        // directly to the receiver, bypassing the channel buffer (if any).
        send(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
        return true
    }

    if c.qcount &amp;lt; c.dataqsiz {
        // Space is available in the channel buffer. Enqueue the element to send.
        qp := chanbuf(c, c.sendx)
        if raceenabled {
            raceacquire(qp)
            racerelease(qp)
        }
        typedmemmove(c.elemtype, qp, ep)
        c.sendx++
        if c.sendx == c.dataqsiz {
            c.sendx = 0
        }
        c.qcount++
        unlock(&amp;amp;c.lock)
        return true
    }

    if !block {
        unlock(&amp;amp;c.lock)
        return false
    }

    // Block on the channel. Some receiver will complete our operation for us.
    gp := getg()
    mysg := acquireSudog()
    mysg.releasetime = 0
    if t0 != 0 {
        mysg.releasetime = -1
    }
    // No stack splits between assigning elem and enqueuing mysg
    // on gp.waiting where copystack can find it.
    mysg.elem = ep
    mysg.waitlink = nil
    mysg.g = gp
    mysg.selectdone = nil
    mysg.c = c
    gp.waiting = mysg
    gp.param = nil
    c.sendq.enqueue(mysg)
    goparkunlock(&amp;amp;c.lock, &amp;quot;chan send&amp;quot;, traceEvGoBlockSend, 3)

    // someone woke us up.
    if mysg != gp.waiting {
        throw(&amp;quot;G waiting list is corrupted&amp;quot;)
    }
    gp.waiting = nil
    if gp.param == nil {
        if c.closed == 0 {
            throw(&amp;quot;chansend: spurious wakeup&amp;quot;)
        }
        panic(plainError(&amp;quot;send on closed channel&amp;quot;))
    }
    gp.param = nil
    if mysg.releasetime &amp;gt; 0 {
        blockevent(mysg.releasetime-t0, 2)
    }
    mysg.c = nil
    releaseSudog(mysg)
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;nil-channel&#34;&gt;nil channel&lt;/h5&gt;

&lt;p&gt;先来看一下 nil channel 的情况，也就是向没有 make 的 channel 发送数据。上篇文章 深入理解 Go Channel 中留了一个问题：向 nil channel 发送数据会报 fatal error: all goroutines are asleep - deadlock! 错误。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;if c == nil {
    gopark(nil, nil, &amp;quot;chan send (nil chan)&amp;quot;, traceEvGoStop, 2)
    throw(&amp;quot;unreachable&amp;quot;)
}

//runtime/trace.go
traceEvGoStop            = 16 // goroutine stops (like in select{}) [timestamp, stack]

//runtime/proc.go
// Puts the current goroutine into a waiting state and calls unlockf.
// If unlockf returns false, the goroutine is resumed.
// unlockf must not access this G&#39;s stack, as it may be moved between
// the call to gopark and the call to unlockf.
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason string, traceEv byte, traceskip int) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gopark 会将当前 goroutine 休眠，然后通过 unlockf 来唤醒，注意我们上面传入的 unlockf 是 nil，也就是向 nil channel 发送数据的 goroutine 会一直休眠。同理，从 nil channel 读数据也是一样的处理。我们再看一眼上一篇文章的例子。&lt;/p&gt;

&lt;h5 id=&#34;closed-channel&#34;&gt;closed channel&lt;/h5&gt;

&lt;p&gt;向 close 的 channel 发送数据，直接 panic。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lock(&amp;amp;c.lock)

if c.closed != 0 {
    unlock(&amp;amp;c.lock)
    panic(plainError(&amp;quot;send on closed channel&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;发送数据处理&#34;&gt;发送数据处理&lt;/h5&gt;

&lt;p&gt;发送数据分三种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有 goroutine 阻塞在 channel 上，此时 hchan.buf 为空：直接将数据发送给该 goroutine。&lt;/li&gt;
&lt;li&gt;当前 hchan.buf 还有可用空间：将数据放到 buffer 里面。&lt;/li&gt;
&lt;li&gt;当前 hchan.buf 已满：阻塞当前 goroutine。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第一种情况如下。从当前 channel 的等待队列中取出等待的 goroutine，然后调用 send。goready 负责唤醒 goroutine。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lock(&amp;amp;c.lock)

if sg := c.recvq.dequeue(); sg != nil {
    // Found a waiting receiver. We pass the value we want to send
    // directly to the receiver, bypassing the channel buffer (if any).
    send(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
    return true
}

// send processes a send operation on an empty channel c.
// The value ep sent by the sender is copied to the receiver sg.
// The receiver is then woken up to go on its merry way.
// Channel c must be empty and locked.  send unlocks c with unlockf.
// sg must already be dequeued from c.
// ep must be non-nil and point to the heap or the caller&#39;s stack.
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    ... 
    if sg.elem != nil {
        sendDirect(c.elemtype, sg, ep)
        sg.elem = nil
    }
    gp := sg.g
    unlockf()
    gp.param = unsafe.Pointer(sg)
    if sg.releasetime != 0 {
        sg.releasetime = cputicks()
    }
    goready(gp, skip+1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二种情况比较简单。通过比较 qcount 和 dataqsiz 来判断 hchan.buf 是否还有可用空间。除此之后还需要调整一下 sendx 和 qcount。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lock(&amp;amp;c.lock)

if c.qcount &amp;lt; c.dataqsiz {
    // Space is available in the channel buffer. Enqueue the element to send.
    qp := chanbuf(c, c.sendx)
    if raceenabled {
        raceacquire(qp)
        racerelease(qp)
    }
    typedmemmove(c.elemtype, qp, ep)
    c.sendx++
    if c.sendx == c.dataqsiz {
        c.sendx = 0
    }
    c.qcount++
    unlock(&amp;amp;c.lock)
    return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三种情况如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Block on the channel. Some receiver will complete our operation for us.
gp := getg()
mysg := acquireSudog()
mysg.releasetime = 0
if t0 != 0 {
    mysg.releasetime = -1
}

mysg.elem = ep          // 一些初始化工作
mysg.waitlink = nil
mysg.g = gp
mysg.selectdone = nil
mysg.c = c
gp.waiting = mysg
gp.param = nil
c.sendq.enqueue(mysg)   // 当前 goroutine 如等待队列
goparkunlock(&amp;amp;c.lock, &amp;quot;chan send&amp;quot;, traceEvGoBlockSend, 3)   //休眠
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;recv&#34;&gt;recv&lt;/h4&gt;

&lt;p&gt;读取 channel （ &amp;lt;-c ）和发送的情况非常类似&lt;/p&gt;

&lt;h5 id=&#34;nil-channel-1&#34;&gt;nil channel&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    if c == nil {
        if !block {
            return
        }
        gopark(nil, nil, &amp;quot;chan receive (nil chan)&amp;quot;, traceEvGoStop, 2)
        throw(&amp;quot;unreachable&amp;quot;)
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;closed-channel-1&#34;&gt;closed channel&lt;/h5&gt;

&lt;p&gt;从 closed channel 接收数据，如果 channel 中还有数据，接着走下面的流程。如果已经没有数据了，则返回默认值。使用 ok-idiom 方式读取的时候，第二个参数返回 false&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lock(&amp;amp;c.lock)

if c.closed != 0 &amp;amp;&amp;amp; c.qcount == 0 {
    if raceenabled {
        raceacquire(unsafe.Pointer(c))
    }
    unlock(&amp;amp;c.lock)
    if ep != nil {
        typedmemclr(c.elemtype, ep)
    }
    return true, false
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;接收数据处理&#34;&gt;接收数据处理&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;// entry points for &amp;lt;- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
    chanrecv(c, elem, true)
}

//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
    _, received = chanrecv(c, elem, true)
    return
}


func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    // raceenabled: don&#39;t need to check ep, as it is always on the stack
    // or is new memory allocated by reflect.

    // 如果在 nil channel 上进行 recv 操作，那么会永远阻塞
    if c == nil {
        if !block {
            // 非阻塞的情况下
            // 要直接返回
            // 非阻塞出现在一些 select 的场景中
            // 参见 selectnbrecv/selectnbrecv2
            return
        }
        // 当前 goroutine: Grunning -&amp;gt; Gwaiting
        // 其实就是该 goroutine 直接泄露 leak 了
        gopark(nil, nil, &amp;quot;chan receive (nil chan)&amp;quot;, traceEvGoStop, 2)

        // 放个 throw 有点莫名其妙
        // 不过这段代码确实永远达到不了
        throw(&amp;quot;unreachable&amp;quot;)
    }

    // Fast path: check for failed non-blocking operation without acquiring the lock.
    //
    // After observing that the channel is not ready for receiving, we observe that the
    // channel is not closed. Each of these observations is a single word-sized read
    // (first c.sendq.first or c.qcount, and second c.closed).
    // Because a channel cannot be reopened, the later observation of the channel
    // being not closed implies that it was also not closed at the moment of the
    // first observation. We behave as if we observed the channel at that moment
    // and report that the receive cannot proceed.
    //
    // The order of operations is important here: reversing the operations can lead to
    // incorrect behavior when racing with a close.
    if !block &amp;amp;&amp;amp; (c.dataqsiz == 0 &amp;amp;&amp;amp; c.sendq.first == nil ||
        c.dataqsiz &amp;gt; 0 &amp;amp;&amp;amp; atomic.Loaduint(&amp;amp;c.qcount) == 0) &amp;amp;&amp;amp;
        atomic.Load(&amp;amp;c.closed) == 0 {
        // 非阻塞且没内容可收的情况下要直接返回
        // 两个 bool 的零值就是 false，false
        return
    }

    var t0 int64
    if blockprofilerate &amp;gt; 0 {
        t0 = cputicks()
    }

    lock(&amp;amp;c.lock)

    // 当前 channel 中没有数据可读
    // 直接返回 not selected
    if c.closed != 0 &amp;amp;&amp;amp; c.qcount == 0 {
        unlock(&amp;amp;c.lock)
        if ep != nil {
            typedmemclr(c.elemtype, ep)
        }
        return true, false
    }

    // sender 队列中有 sudog 在等待
    // 直接从该 sudog 中获取数据拷贝到当前 g 即可
    if sg := c.sendq.dequeue(); sg != nil {
        // Found a waiting sender. If buffer is size 0, receive value
        // directly from sender. Otherwise, receive from head of queue
        // and add sender&#39;s value to the tail of the queue (both map to
        // the same buffer slot because the queue is full).
        recv(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
        return true, true
    }

    if c.qcount &amp;gt; 0 {
        // Receive directly from queue
        qp := chanbuf(c, c.recvx)

        // 直接从 buffer 里拷贝数据
        if ep != nil {
            typedmemmove(c.elemtype, ep, qp)
        }
        typedmemclr(c.elemtype, qp)
        // 接收索引 +1
        c.recvx++
        if c.recvx == c.dataqsiz {
            c.recvx = 0
        }
        // buffer 元素计数 -1
        c.qcount--
        unlock(&amp;amp;c.lock)
        return true, true
    }

    if !block {
        unlock(&amp;amp;c.lock)
        // 非阻塞时，且无数据可收
        // 始终不选中，这是在 buffer 中没内容的时候
        return false, false
    }

    // no sender available: block on this channel.
    gp := getg()
    mysg := acquireSudog()
    mysg.releasetime = 0
    if t0 != 0 {
        mysg.releasetime = -1
    }
    // No stack splits between assigning elem and enqueuing mysg
    // on gp.waiting where copystack can find it.
    // 打包成 sudog
    mysg.elem = ep
    mysg.waitlink = nil
    gp.waiting = mysg
    mysg.g = gp
    mysg.isSelect = false
    mysg.c = c
    gp.param = nil
    // 进入 recvq 队列
    c.recvq.enqueue(mysg)

    // Grunning -&amp;gt; Gwaiting
    goparkunlock(&amp;amp;c.lock, &amp;quot;chan receive&amp;quot;, traceEvGoBlockRecv, 3)

    // someone woke us up
    // 被唤醒
    if mysg != gp.waiting {
        throw(&amp;quot;G waiting list is corrupted&amp;quot;)
    }
    gp.waiting = nil
    if mysg.releasetime &amp;gt; 0 {
        blockevent(mysg.releasetime-t0, 2)
    }
    closed := gp.param == nil
    gp.param = nil
    mysg.c = nil
    releaseSudog(mysg)
    // 如果 channel 未被关闭，那就是真的 recv 到数据了
    return true, !closed
}

// recv processes a receive operation on a full channel c.
// There are 2 parts:
// 1) The value sent by the sender sg is put into the channel
//    and the sender is woken up to go on its merry way.
// 2) The value received by the receiver (the current G) is
//    written to ep.
// For synchronous channels, both values are the same.
// For asynchronous channels, the receiver gets its data from
// the channel buffer and the sender&#39;s data is put in the
// channel buffer.
// Channel c must be full and locked. recv unlocks c with unlockf.
// sg must already be dequeued from c.
// A non-nil ep must point to the heap or the caller&#39;s stack.
func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    if c.dataqsiz == 0 {
        if ep != nil {
            // copy data from sender
            recvDirect(c.elemtype, sg, ep)
        }
    } else {
        // Queue is full. Take the item at the
        // head of the queue. Make the sender enqueue
        // its item at the tail of the queue. Since the
        // queue is full, those are both the same slot.
        qp := chanbuf(c, c.recvx)

        // copy data from queue to receiver
        // 英文写的很明白
        if ep != nil {
            typedmemmove(c.elemtype, ep, qp)
        }
        // copy data from sender to queue
        // 英文写的很明白
        typedmemmove(c.elemtype, qp, sg.elem)
        c.recvx++
        if c.recvx == c.dataqsiz {
            c.recvx = 0
        }
        c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz
    }
    sg.elem = nil
    gp := sg.g
    unlockf()
    gp.param = unsafe.Pointer(sg)
    if sg.releasetime != 0 {
        sg.releasetime = cputicks()
    }

    // Gwaiting -&amp;gt; Grunnable
    goready(gp, skip+1)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;关闭channel&#34;&gt;关闭channel&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;func closechan(c *hchan) {
    if c == nil {
        panic(plainError(&amp;quot;close of nil channel&amp;quot;))
    }

    lock(&amp;amp;c.lock)
    if c.closed != 0 {
        unlock(&amp;amp;c.lock)
        panic(plainError(&amp;quot;close of closed channel&amp;quot;))
    }

    c.closed = 1

    var glist *g

    // release all readers
    for {
        sg := c.recvq.dequeue()
        if sg == nil {
            break
        }
        if sg.elem != nil {
            typedmemclr(c.elemtype, sg.elem)
            sg.elem = nil
        }
        if sg.releasetime != 0 {
            sg.releasetime = cputicks()
        }
        gp := sg.g
        gp.param = nil
        if raceenabled {
            raceacquireg(gp, unsafe.Pointer(c))
        }
        gp.schedlink.set(glist)
        glist = gp
    }

    // release all writers (they will panic)
    for {
        sg := c.sendq.dequeue()
        if sg == nil {
            break
        }
        sg.elem = nil
        if sg.releasetime != 0 {
            sg.releasetime = cputicks()
        }
        gp := sg.g
        gp.param = nil
        if raceenabled {
            raceacquireg(gp, unsafe.Pointer(c))
        }
        gp.schedlink.set(glist)
        glist = gp
    }
    unlock(&amp;amp;c.lock)

    // Ready all Gs now that we&#39;ve dropped the channel lock.
    for glist != nil {
        gp := glist
        glist = glist.schedlink.ptr()
        gp.schedlink = 0
        goready(gp, 3)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;close channel 的工作除了将 c.closed 设置为 1。还需要：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;唤醒 recvq 队列里面的阻塞 goroutine&lt;/li&gt;
&lt;li&gt;唤醒 sendq 队列里面的阻塞 goroutine
处理方式是分别遍历 recvq 和 sendq 队列，将所有的 goroutine 放到 glist 队列中，最后唤醒 glist 队列中的 goroutine。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;h3 id=&#34;参考链接&#34;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://my.oschina.net/renhc/blog/2246871&#34;&gt;https://my.oschina.net/renhc/blog/2246871&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://legendtkl.com/2017/08/06/golang-channel-implement/&#34;&gt;http://legendtkl.com/2017/08/06/golang-channel-implement/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://xargin.com/channel-from-usage-to-src-analysis/&#34;&gt;http://xargin.com/channel-from-usage-to-src-analysis/&lt;/a&gt;
&lt;a href=&#34;http://legendtkl.com/2017/07/30/understanding-golang-channel/&#34;&gt;http://legendtkl.com/2017/07/30/understanding-golang-channel/&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>[转]golang 反射</title>
      <link>https://jayhong.github.io/post/20190306-golang%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jayhong.github.io/post/20190306-golang%E5%8F%8D%E5%B0%84/</guid>
      
        <description>

&lt;p&gt;转自 &lt;a href=&#34;https://juejin.im/post/5a75a4fb5188257a82110544#heading-2&#34;&gt;https://juejin.im/post/5a75a4fb5188257a82110544#heading-2&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;什么是反射&#34;&gt;什么是反射&lt;/h2&gt;

&lt;p&gt;反射在计算机领域是一种能够通过类型来检查自己的值的能力，在golang中反射提供了一种机制在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，
但是在编译时并不知道这些变量的具体类型。不同的编程语言提供的反射机制不一样。&lt;/p&gt;

&lt;h2 id=&#34;types-和-interfaces&#34;&gt;Types 和 interfaces&lt;/h2&gt;

&lt;p&gt;学习放射首先要知道golang中关于类型的一些原则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;变量包括type，value 两部分&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;type 包括 static type和concrete type. 简单来说 static type是你在编码是看见的类型(如int、string)，concrete type是runtime系统看见的类型&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;类型断言能否成功，取决于变量的concrete type，而不是static type. 因此，一个 reader变量如果它的concrete type也实现了write方法的话，它也可以被类型断言为writer.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来要讲的反射，就是建立在类型之上的，Golang的指定类型的变量的类型是静态的（也就是指定int、string这些的变量，它的type是static type），
在创建变量的时候就已经确定，反射主要与Golang的interface类型相关（它的type是concrete type），只有interface类型才有反射一说。&lt;/p&gt;

&lt;p&gt;在Golang的实现中，每个interface变量都有一个对应pair，pair中记录了实际变量的值和类型:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(value, type)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;value是实际变量值，type是实际变量的类型。一个interface{}类型的变量包含了2个指针，一个指针指向值的类型【对应concrete type】，另外一个指针指向实际的值【对应value】。&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var r io.Reader
tty, err := os.OpenFile(&amp;quot;/dev/tty&amp;quot;, os.O_RDWR, 0)
if err != nil {
    return nil, err
}
r = tty
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口变量r的pair中将记录如下信息：(tty, *os.File)，这个pair在接口变量的连续赋值过程中是不变的，将接口变量r赋给另一个接口变量w:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var w io.Writer
w = r.(io.Writer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接口变量w的pair与r的pair相同，都是:(tty, *os.File)，即使w是空接口类型，pair也是不变的。
interface及其pair的存在，是Golang中实现反射的前提，理解了pair，就更容易理解反射。反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。&lt;/p&gt;

&lt;h2 id=&#34;golang中的反射&#34;&gt;golang中的反射&lt;/h2&gt;

&lt;h4 id=&#34;reflect的基本功能typeof和valueof&#34;&gt;reflect的基本功能TypeOf和ValueOf&lt;/h4&gt;

&lt;p&gt;既然反射就是用来检测存储在接口变量内部(值value；类型concrete type) pair对的一种机制。那么在Golang的reflect反射包中有什么样的方式可以让我们直接获取到变量内部的信息呢？
提供了两种类型（或者说两个方法）让我们可以很容易的访问接口变量内容，分别是reflect.ValueOf() 和 reflect.TypeOf()，看看官方的解释&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ValueOf returns a new Value initialized to the concrete value
// stored in the interface i.  ValueOf(nil) returns the zero 
func ValueOf(i interface{}) Value {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// TypeOf returns the reflection Type that represents the dynamic type of i.
// If i is a nil interface value, TypeOf returns nil.
func TypeOf(i interface{}) Type {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reflect.TypeOf()是获取pair中的type，reflect.ValueOf()获取pair中的value，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

func main() {
    var x float64 = 3.4
    fmt.Println(&amp;quot;type:&amp;quot;, reflect.TypeOf(x))
    fmt.Println(&amp;quot;value: &amp;quot;, reflect.ValueOf(num))
}

运行结果:
type:  float64
value:  3.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明&#34;&gt;说明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;reflect.TypeOf： 直接给到了我们想要的type类型，如float64、int、各种pointer、struct 等等真实的类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reflect.ValueOf：直接给到了我们想要的具体的值，如1.2345这个具体数值，或者类似&amp;amp;{1 &amp;ldquo;Allen.Wu&amp;rdquo; 25} 这样的结构体struct的值&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也就是说明反射可以将“接口类型变量”转换为“反射类型对象”，反射类型指的是reflect.Type和reflect.Value这两种&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;从relfect-value中获取接口interface的信息&#34;&gt;从relfect.Value中获取接口interface的信息&lt;/h4&gt;

&lt;p&gt;当执行reflect.ValueOf(interface)之后，就得到了一个类型为”relfect.Value”变量，可以通过它本身的Interface()方法获得接口变量的真实内容，
然后可以通过类型判断进行转换，转换为原有真实类型。不过，我们可能是已知原有类型，也有可能是未知原有类型，因此，下面分两种情况进行说明。&lt;/p&gt;

&lt;h5 id=&#34;已知原有类型-进行-强制转换&#34;&gt;已知原有类型【进行“强制转换”】&lt;/h5&gt;

&lt;p&gt;已知类型后转换为其对应的类型的做法如下，直接通过Interface方法然后强制转换，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;realValue := value.Interface().(已知的类型)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

func main() {
    var num float64 = 1.2345

    pointer := reflect.ValueOf(&amp;amp;num)
    value := reflect.ValueOf(num)

    // 可以理解为“强制转换”，但是需要注意的时候，转换的时候，如果转换的类型不完全符合，则直接panic
    // Golang 对类型要求非常严格，类型一定要完全符合
    // 如下两个，一个是*float64，一个是float64，如果弄混，则会panic
    convertPointer := pointer.Interface().(*float64)
    convertValue := value.Interface().(float64)

    fmt.Println(convertPointer)
    fmt.Println(convertValue)
}

运行结果：
0xc42000e238
1.2345
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明-1&#34;&gt;说明&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;转换的时候，如果转换的类型不完全符合，则直接panic，类型要求非常严格！&lt;/li&gt;
&lt;li&gt;转换的时候，要区分是指针还是值&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;未知原有类型-遍历探测其filed&#34;&gt;未知原有类型【遍历探测其Filed】&lt;/h4&gt;

&lt;p&gt;很多情况下，我们可能并不知道其具体类型，那么这个时候，该如何做呢？需要我们进行遍历探测其Filed来得知，示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

type User struct {
    Id   int
    Name string
    Age  int
}

func (u User) ReflectCallFunc() {
    fmt.Println(&amp;quot;Allen.Wu ReflectCallFunc&amp;quot;)
}

func main() {

    user := User{1, &amp;quot;Allen.Wu&amp;quot;, 25}

    DoFiledAndMethod(user)

}

// 通过接口来获取任意参数，然后一一揭晓
func DoFiledAndMethod(input interface{}) {

    getType := reflect.TypeOf(input)
    fmt.Println(&amp;quot;get Type is :&amp;quot;, getType.Name())

    getValue := reflect.ValueOf(input)
    fmt.Println(&amp;quot;get all Fields is:&amp;quot;, getValue)

    // 获取方法字段
    // 1. 先获取interface的reflect.Type，然后通过NumField进行遍历
    // 2. 再通过reflect.Type的Field获取其Field
    // 3. 最后通过Field的Interface()得到对应的value
    for i := 0; i &amp;lt; getType.NumField(); i++ {
        field := getType.Field(i)
        value := getValue.Field(i).Interface()
        fmt.Printf(&amp;quot;%s: %v = %v\n&amp;quot;, field.Name, field.Type, value)
    }

    // 获取方法
    // 1. 先获取interface的reflect.Type，然后通过.NumMethod进行遍历
    for i := 0; i &amp;lt; getType.NumMethod(); i++ {
        m := getType.Method(i)
        fmt.Printf(&amp;quot;%s: %v\n&amp;quot;, m.Name, m.Type)
    }
}

运行结果：
get Type is : User
get all Fields is: {1 Allen.Wu 25}
Id: int = 1
Name: string = Allen.Wu
Age: int = 25
ReflectCallFunc: func(main.User)

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;说明-2&#34;&gt;说明&lt;/h5&gt;

&lt;p&gt;通过运行结果可以得知获取未知类型的interface的具体变量及其类型的步骤为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumField进行遍历&lt;/li&gt;
&lt;li&gt;再通过reflect.Type的Field获取其&lt;code&gt;Field&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最后通过Field的Interface()得到对应的value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过运行结果可以得知获取未知类型的interface的所属方法（函数）的步骤为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;先获取interface的reflect.Type，然后通过NumMethod进行遍历&lt;/li&gt;
&lt;li&gt;再分别通过reflect.Type的&lt;code&gt;Method&lt;/code&gt;获取对应的真实的方法（函数）&lt;/li&gt;
&lt;li&gt;最后对结果取其Name和Type得知具体的方法名&lt;/li&gt;
&lt;li&gt;也就是说反射可以将“反射类型对象”再重新转换为“接口类型变量”
struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;通过reflect-value设置实际变量的值&#34;&gt;通过reflect.Value设置实际变量的值&lt;/h4&gt;

&lt;p&gt;reflect.Value是通过reflect.ValueOf(X)获得的，只有当X是指针的时候，才可以通过reflec.Value修改实际变量X的值，即：要修改反射类型的对象就一定要保证其值是“addressable”的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

func main() {

    var num float64 = 1.2345
    fmt.Println(&amp;quot;old value of pointer:&amp;quot;, num)

    // 通过reflect.ValueOf获取num中的reflect.Value，注意，参数必须是指针才能修改其值
    pointer := reflect.ValueOf(&amp;amp;num)
    newValue := pointer.Elem()

    fmt.Println(&amp;quot;type of pointer:&amp;quot;, newValue.Type())
    fmt.Println(&amp;quot;settability of pointer:&amp;quot;, newValue.CanSet())

    // 重新赋值
    newValue.SetFloat(77)
    fmt.Println(&amp;quot;new value of pointer:&amp;quot;, num)

    ////////////////////
    // 如果reflect.ValueOf的参数不是指针，会如何？
    pointer = reflect.ValueOf(num)
    //newValue = pointer.Elem() // 如果非指针，这里直接panic，“panic: reflect: call of reflect.Value.Elem on float64 Value”
}

运行结果：
old value of pointer: 1.2345
type of pointer: float64
settability of pointer: true
new value of pointer: 77
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要传入的参数是* float64这个指针，然后可以通过pointer.Elem()去获取所指向的Value，注意一定要是指针。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果传入的参数不是指针，而是变量，那么&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通过Elem获取原始值对应的对象则直接panic&lt;/li&gt;
&lt;li&gt;通过CanSet方法查询是否可以设置返回false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;newValue.CantSet()表示是否可以重新设置其值，如果输出的是true则可修改，否则不能修改，修改完之后再进行打印发现真的已经修改了。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;reflect.Value.Elem() 表示获取原始值对应的反射对象，只有原始对象才能修改，当前反射对象是不能修改的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也就是说如果要修改反射类型对象，其值必须是“addressable”【对应的要传入的是指针，同时要通过Elem方法获取原始值对应的反射对象】&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struct 或者 struct 的嵌套都是一样的判断处理方式&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;通过reflect-valueof来进行方法的调用&#34;&gt;通过reflect.ValueOf来进行方法的调用&lt;/h4&gt;

&lt;p&gt;这算是一个高级用法了，前面我们只说到对类型、变量的几种反射的用法，包括如何获取其值、其类型、如果重新设置新值。但是在工程应用中，另外一个常用并且属于高级的用法，就是通过reflect来进行方法【函数】的调用。比如我们要做框架工程的时候，需要可以随意扩展方法，或者说用户可以自定义方法，那么我们通过什么手段来扩展让用户能够自定义呢？关键点在于用户的自定义方法是未可知的，因此我们可以通过reflect来搞定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;reflect&amp;quot;
)

type User struct {
    Id   int
    Name string
    Age  int
}

func (u User) ReflectCallFuncHasArgs(name string, age int) {
    fmt.Println(&amp;quot;ReflectCallFuncHasArgs name: &amp;quot;, name, &amp;quot;, age:&amp;quot;, age, &amp;quot;and origal User.Name:&amp;quot;, u.Name)
}

func (u User) ReflectCallFuncNoArgs() {
    fmt.Println(&amp;quot;ReflectCallFuncNoArgs&amp;quot;)
}

// 如何通过反射来进行方法的调用？
// 本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调动mv.Call

func main() {
    user := User{1, &amp;quot;Allen.Wu&amp;quot;, 25}
    
    // 1. 要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理
    getValue := reflect.ValueOf(user)

    // 一定要指定参数为正确的方法名
    // 2. 先看看带有参数的调用方法
    methodValue := getValue.MethodByName(&amp;quot;ReflectCallFuncHasArgs&amp;quot;)
    args := []reflect.Value{reflect.ValueOf(&amp;quot;wudebao&amp;quot;), reflect.ValueOf(30)}
    methodValue.Call(args)

    // 一定要指定参数为正确的方法名
    // 3. 再看看无参数的调用方法
    methodValue = getValue.MethodByName(&amp;quot;ReflectCallFuncNoArgs&amp;quot;)
    args = make([]reflect.Value, 0)
    methodValue.Call(args)
}


运行结果：
ReflectCallFuncHasArgs name:  wudebao , age: 30 and origal User.Name: Allen.Wu
ReflectCallFuncNoArgs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要通过反射来调用起对应的方法，必须要先通过reflect.ValueOf(interface)来获取到reflect.Value，得到“反射类型对象”后才能做下一步处理&lt;/li&gt;
&lt;li&gt;reflect.Value.MethodByName这.MethodByName，需要指定准确真实的方法名字，如果错误将直接panic，MethodByName返回一个函数值对应的reflect.Value方法的名字。&lt;/li&gt;
&lt;li&gt;[]reflect.Value，这个是最终需要调用的方法的参数，可以没有或者一个或者多个，根据实际参数来定。&lt;/li&gt;
&lt;li&gt;reflect.Value的 Call 这个方法，这个方法将最终调用真实的方法，参数务必保持一致，如果reflect.Value&amp;rsquo;Kind不是一个方法，那么将直接panic。&lt;/li&gt;
&lt;li&gt;本来可以用u.ReflectCallFuncXXX直接调用的，但是如果要通过反射，那么首先要将方法注册，也就是MethodByName，然后通过反射调用methodValue.Call&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;json转码的例子&#34;&gt;json转码的例子&lt;/h4&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;上述详细说明了Golang的反射reflect的各种功能和用法，都附带有相应的示例，相信能够在工程应用中进行相应实践，总结一下就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射可以大大提高程序的灵活性，使得interface{}有更大的发挥余地&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;反射必须结合interface才玩得转&lt;/li&gt;
&lt;li&gt;变量的type要是concrete type的（也就是interface变量）才有反射一说&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反射可以将“接口类型变量”转换为“反射类型对象”&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;反射使用 TypeOf 和 ValueOf 函数从接口中获取目标对象信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反射可以将“反射类型对象”转换为“接口类型变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;reflect.value.Interface().(已知的类型)&lt;/li&gt;
&lt;li&gt;遍历reflect.Type的Field获取其Field&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反射可以修改反射类型对象，但是其值必须是“addressable”&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;想要利用反射修改对象状态，前提是 interface.data 是 settable,即 pointer-interface&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过反射可以“动态”调用方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为Golang本身不支持模板，因此在以往需要使用模板的场景下往往就需要使用反射(reflect)来实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考链接&#34;&gt;参考链接&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.golang.org/laws-of-reflection&#34;&gt;https://blog.golang.org/laws-of-reflection&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://juejin.im/post/5a75a4fb5188257a82110544#heading-2&#34;&gt;https://juejin.im/post/5a75a4fb5188257a82110544#heading-2&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://www.zhihu.com/question/28570203&#34;&gt;https://www.zhihu.com/question/28570203&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么开这个博客</title>
      <link>https://jayhong.github.io/post/20190305-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://jayhong.github.io/post/20190305-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2/</guid>
      
        <description>

&lt;h2 id=&#34;从什么时候开始写博客&#34;&gt;从什么时候开始写博客&lt;/h2&gt;

&lt;p&gt;其实早在我还没有毕业的时候，就已经有写一些博客。当时是写在csdn上面，说起来也是搞笑，因为写的文件里面会带一些引用的链接，然后就被csdn封掉了，申诉之后的原因就是说我的文章带有很多外链
。被当成是垃圾博客了。当时写博客很大的一个原因就是因为要找工作，找工作的时候就可以在自己的简历上写上blog地址，
其实想想也是挺急功近利的。后来自己买了个云主机买了个域名，也用hugo弄了一个博客，但是还是没能坚持下来。去年11月份也到期了没有继续续费了。&lt;/p&gt;

&lt;h2 id=&#34;为啥要写博客&#34;&gt;为啥要写博客&lt;/h2&gt;

&lt;p&gt;作为一个软件开发人员，需要不停地学习。学习的过程中是一个不断整理归纳的过程，前几年看的技术书籍非技术书籍，算下来也有10多本，但是真正沉淀下来的知识却
少得可怜，而且很多知识没办法串成一棵树，而且我发现表达能力，特别是技术的表达能力我目前还是挺欠缺的。所以想着锻炼一下自己。刚好目前的工作任务也比之前少了一些。
之前会把工作记录到有道云里面，但是我翻了一下发现很多都是不完整的。所以顺便整理一下。说不定我的一些文章还可以帮到一些朋友呢。&lt;/p&gt;

&lt;h2 id=&#34;博客的内容&#34;&gt;博客的内容&lt;/h2&gt;

&lt;p&gt;在这里写的文章应该会以技术为主，可能也会穿插一些对生活的感悟吧。毕竟我觉得我还是一个比较喜欢无病呻吟的人。所以借此立下一个flag。一周至少发几篇技术或者非技术文字吧。
技术的话我会先将前几年学习的东西都整理一遍。&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>